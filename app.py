import streamlit as st
import google.generativeai as genai
import os
import requests
import json
from datetime import datetime, timedelta
import pandas as pd
import yfinance as yf
import matplotlib.pyplot as plt
import plotly.graph_objects as go
from plotly.subplots import make_subplots

import google.generativeai as genai
import json
def get_future_outlook_explanation(ticker, start_price, current_price, growth_rate):
    """
    Uses Gemini to provide a qualitative interpretation of a stock forecast,
    using historical performance as context.
    """
    prompt = f"""
    You are a senior financial analyst providing a qualitative interpretation of a 1-month stock price forecast chart for {ticker}.

    Use the following historical context and the visual implications of the forecast to generate your analysis. Do not mention that you are looking at an image or chart.

    **Historical Performance (Last 12 Months):**
    - Price 1 year ago: ${start_price:.2f}
    - Current Price: ${current_price:.2f}
    - 1-Year Growth Rate: {growth_rate:.2f}%

    **Your Task:**
    Based on the historical performance provided above and the trajectory of the 1-month forecast, provide a detailed future outlook.

    1.  **Executive Summary:** Start with a brief summary connecting the past year's performance with the short-term forecast. For example, "After a significant growth of {growth_rate:.2f}% over the past year, the short-term forecast for {ticker} suggests a period of consolidation/continued momentum/a potential pullback."

    2.  **Interpreting the Forecast Trajectory:** Describe the predicted movement for the next month (e.g., bullish, bearish, sideways). Is the model predicting an acceleration of the past trend, a reversal, or a slowdown? Mention the expected volatility.

    3.  **Analysis and Key Factors:** Analyze WHY this might be happening.
        - If the forecast continues a strong growth trend, what could be driving it? (e.g., "This sustained momentum could be fueled by strong market positioning and anticipated positive earnings.")
        - If the forecast shows a slowdown or reversal, what could be the cause? (e.g., "This projected pullback could indicate that the stock is overbought after its recent run-up, suggesting a healthy correction may be on the horizon.")
        - Mention 2-3 hypothetical factors (e.g., macroeconomic conditions, sector trends, company-specific news) that could influence this outlook.

    4.  **Concluding Disclaimer:** End with a strong disclaimer that this is a model-based interpretation and not financial advice, and that real-world events can alter the outcome.

    Your tone must be professional, insightful, and directly address the provided data.
    """
    model = genai.GenerativeModel(model_name="gemini-flash-lite-latest")
    response = model.generate_content(prompt)
    return response.text

def get_portfolio_insights(portfolio_data, market_data):
    """
    Analyzes a user's portfolio against market data using the Gemini LLM.

    Args:
        portfolio_data (list): A list of dictionaries, where each dictionary represents a stock holding.
        market_data (dict): A dictionary containing the latest market analysis and sentiment.

    Returns:
        str: A detailed strategic analysis report generated by the language model.
    """
    prompt = f"""
    You are a world-class portfolio strategist and senior financial advisor. Your task is to conduct a thorough analysis of a client's investment portfolio, considering the latest market conditions.

    **Current Market Analysis:**
    - Sentiment: {market_data.get('sentiment', 'N/A')}
    - Summary: {market_data.get('latest_analysis', {}).get('summary', 'No summary available.')}
    - Key Trends: {market_data.get('latest_analysis', {}).get('trends', [])}

    **Client's Portfolio Details:**
    {json.dumps(portfolio_data, indent=2)}

    **Your Required Analysis (Provide a detailed, strategic report with the following sections):**

    1.  **Executive Summary:** Begin with a high-level overview of the portfolio's total value, overall return (in both percentage and absolute terms), and its most significant holdings.

    2.  **Portfolio Composition and Diversification:** Analyze the asset allocation and sector concentration. Is the portfolio heavily weighted in a particular sector (e.g., technology, consumer goods)? Discuss the potential benefits and risks of this concentration in light of the current market trends.

    3.  **Individual Asset Performance Review:** Comment on the performance of each stock. Identify the top-performing assets that are driving gains and any underperforming assets that may be a drag on the portfolio.

    4.  **Strategic Recommendations:** Based on your complete analysis, provide 3-5 concrete, actionable recommendations. These should be strategic in nature. For each recommendation, provide a clear rationale linked to the market analysis and the portfolio's current state. Examples:
        - "Consider rebalancing by taking some profits from [top_performer] to mitigate concentration risk and reinvesting in the under-represented [sector] sector, which shows resilience based on current market trends."
        - "Hold your position in [stock] despite recent dips, as market trends suggest a potential rebound in its sector."
        - "Increase exposure to [sector] to capitalize on the [specific_trend] trend identified in the market analysis."

    5.  **Overall Risk Assessment:** Conclude with a brief assessment of the portfolio's main risks, such as market volatility, concentration risk, or interest rate sensitivity.

    Your tone must be professional, authoritative, and insightful, providing the client with clear strategic guidance.
    """
    
    # Initialize the Generative Model
    model = genai.GenerativeModel(model_name="gemini-flash-lite-latest")
    
    # Generate the content based on the prompt
    response = model.generate_content(prompt)
    
    return response.text

GEMINI_API_KEY = st.secrets["gemini_api_key"]
SERPER_API_KEY = st.secrets["serper_api_key"]


genai.configure(api_key=GEMINI_API_KEY)
st.set_page_config(page_title="Fin-AI-lytics", layout="wide")
st.title("Fin-AI-lytics")
if "messages" not in st.session_state:
    st.session_state.messages = []
if "financial_context" not in st.session_state:
    st.session_state.financial_context = {
        "goals": [],
        "budget": {},
        "investments": [],
        "savings": {},
        "expenses": [],
        "portfolio": []
    }
if "market_data" not in st.session_state:
    st.session_state.market_data = {
        "latest_analysis": None,
        "sentiment": None,
        "last_updated": None
    }
if "budget_categories" not in st.session_state:
    st.session_state.budget_categories = ["Housing", "Food", "Transportation", "Utilities", "Entertainment", "Healthcare", "Shopping", "Other"]
def get_market_news(query, num_results=5):
    url = "https://google.serper.dev/search"
    payload = json.dumps({
        "q": query,
        "num": num_results
    })
    headers = {
        'X-API-KEY': SERPER_API_KEY,
        'Content-Type': 'application/json'
    }
    try:
        response = requests.request("POST", url, headers=headers, data=payload)
        return response.json()
    except Exception as e:
        st.error(f"Error fetching market news: {e}")
        return None
def detect_fraud_in_transactions(transactions):
    fraud_indicators = []
    if len(transactions) > 0:
        sorted_transactions = sorted(transactions, key=lambda x: x.get('date', ''))
        avg_amount = sum(t.get('amount', 0) for t in transactions) / len(transactions)
        threshold = avg_amount * 3
        for transaction in transactions:
            fraud_score = 0
            reasons = []
            if transaction.get('amount', 0) > threshold:
                fraud_score += 30
                reasons.append("Unusually large transaction amount")
            if transaction.get('location_usual', True) == False:
                fraud_score += 25
                reasons.append("Unusual transaction location")
            if transaction.get('category_usual', True) == False:
                fraud_score += 20
                reasons.append("Unusual merchant category")
            if transaction.get('time_usual', True) == False:
                fraud_score += 15
                reasons.append("Unusual transaction time")
            if transaction.get('rapid_succession', False):
                fraud_score += 25
                reasons.append("Multiple transactions in rapid succession")
            if fraud_score >= 40:
                transaction['fraud_score'] = fraud_score
                transaction['fraud_reasons'] = reasons
                fraud_indicators.append(transaction)
    return fraud_indicators
if "transactions" not in st.session_state:
    st.session_state.transactions = []
def analyze_market_sentiment(news_data):
    if not news_data or 'organic' not in news_data:
        return {"error": "Insufficient news data provided.", "summary": "Unable to analyze market sentiment due to insufficient data.", "sentiment": "Unknown"}

    news_articles = []
    for article in news_data.get('organic', []):
        news_articles.append({
            'title': article.get('title', ''),
            'snippet': article.get('snippet', ''),
            'date': article.get('date', '')
        })
        
    prompt = f"""
    Consider you are the best financial scientist in the entire world.
    Make sure you directly stick to the topic and do not beat around the bush due to poor news quality or due to being news being off topic.
    Analyze the following financial news articles for market sentiment:
    {json.dumps(news_articles, indent=2)}
    Based on these articles:
    1. Provide a detailed summary of about 2500 words of current market conditions
    2. Analyze the overall market sentiment (bullish, bearish, or neutral)
    3. Identify key trends or patterns mentioned
    4. Give a market outlook prediction (positive, negative, or uncertain)
    Format your response STRICTLY as a JSON object with these keys: summary, sentiment, trends, outlook, confidence_score (0-100). Do not include any text or markdown formatting before or after the JSON object.
    """
    
    model = genai.GenerativeModel(model_name="gemini-flash-lite-latest")
    try:
        response = model.generate_content(prompt)
        analysis_text = response.text
        
        # Clean the response: LLMs sometimes wrap JSON in markdown
        if '```json' in analysis_text:
            analysis_text = analysis_text.split('```json').split('```')[0].strip()

        json_start = analysis_text.find('{')
        json_end = analysis_text.rfind('}') + 1
        
        if json_start != -1 and json_end != -1:
            json_str = analysis_text[json_start:json_end]
            return json.loads(json_str)
        else:
            # If no JSON is found, return an error dictionary
            return {"error": "Could not parse JSON from LLM response", "summary": analysis_text, "sentiment": "Unknown"}
            
    except Exception as e:
        # If any other error occurs, return an error dictionary
        return {"error": str(e), "summary": f"An error occurred during analysis: {e}", "sentiment": "Unknown"}
def get_gemini_response(messages, financial_context, market_data):
        system_prompt = f"""
        You are a Smart Financial Assistant with the following capabilities:
        - Real-time query handling for financial questions
        - Context-aware responses based on user goals
        User's financial context:
        Goals: {financial_context['goals']}
        Budget: {financial_context['budget']}
        Investments: {financial_context['investments']}
        Savings: {financial_context['savings']}
        Expenses: {financial_context['expenses']}
        Portfolio: {financial_context['portfolio']}
        Recent market analysis:
        {market_data.get('latest_analysis', 'No recent market analysis available')}
        Sentiment: {market_data.get('sentiment', 'Unknown')}
        Last updated: {market_data.get('last_updated', 'Never')}
        Respond in a helpful, professional manner. Provide specific, actionable financial advice based on the user's goals and context.
        """
        model = genai.GenerativeModel(
            model_name="gemini-flash-lite-latest",
            system_instruction=system_prompt
        )
        conversation = []
        for msg in messages:
            role = "user" if msg["role"] == "user" else "model"
            conversation.append({"role": role, "parts": [msg["content"]]})
        response = model.generate_content(conversation)
        return response.text
def get_explainable_ai_forecast(ticker):
    prompt = f"""
    You are an expert financial data scientist and a master of explainable AI (XAI). A stock forecast for {ticker} was generated, and the user wants a detailed, step-by-step explanation of the methodology.

    Your explanation must be clear, professional, and educational. Do not mention that you are looking at an image. Instead, act as if you have personally conducted the analysis and are presenting your workflow.

    Structure your explanation into the following sections:

    **1. Data Foundation: Cleaning and Preprocessing**
    - Start by describing the raw time series data used (Open, High, Low, Close, Volume).
    - Explain the importance of data integrity and the preprocessing steps you took:
        - **Handling Missing Values:** Detail methods like forward-fill, backward-fill, and interpolation, explaining why they are chosen for financial data.
        - **Outlier Detection:** Describe how you identify and handle outliers using statistical methods like Z-score or Interquartile Range (IQR) to prevent them from skewing the model.

    **2. Time Series Decomposition**
    - Explain that before modeling, you decompose the time series to understand its underlying structure.
    - Describe the **Seasonal-Trend-Loess (STL)** decomposition method, breaking the data down into three components:
        - **Trend:** The long-term direction of the price.
        - **Seasonality:** Regular, periodic fluctuations.
        - **Residuals:** The random, unpredictable noise left over.
    - Mention that the Trend and Seasonality component charts visualize this decomposition.

    **3. Forecasting Models and Methodology**
    - Explain that a single model is often insufficient for volatile financial markets, so you employ a hybrid approach.
    - **Baseline Models:** Briefly describe simpler methods used for establishing a baseline:
        - **Moving Averages:** Simple and Weighted Moving Averages (SMA/WMA).
        - **Exponential Smoothing:** Methods like Simple Exponential Smoothing (SES), Holt's Linear Trend, and Holt-Winters for data with trend and seasonality.
    - **Advanced Models:**
        - **ARIMA (AutoRegressive Integrated Moving Average):** Explain its strength in modeling linear relationships based on past values and errors.
        - **LSTM (Long Short-Term Memory):** Describe why this deep learning model is powerful for financial data, highlighting its ability to capture complex, non-linear patterns and long-term dependencies.
        - **Hybrid Model:** State that the final forecast combines the strengths of models like ARIMA and LSTM to create a more robust prediction.

    **4. Feature Engineering for Deeper Context**
    - Discuss the creation of additional features to enhance model performance.
    - Mention key **technical indicators** you engineered from the price data, such as:
        - Moving Averages (e.g., 50-day, 200-day)
        - Relative Strength Index (RSI)
        - Bollinger Bands

    **5. Forecast Interpretation and Disclaimer**
    - Conclude by summarizing that the final forecast represents the most probable future price path based on the rigorous analysis of historical patterns and engineered features.
    - Emphasize that this is **not a guarantee** of future performance. All financial forecasts are subject to market risks, volatility, and unforeseen "black swan" events. The forecast is a sophisticated, data-driven guide, not a certainty.
    """
    model = genai.GenerativeModel(model_name="gemini-flash-lite-latest")
    response = model.generate_content(prompt)
    return response.text
def run_automatic_market_analysis():
    analysis_targets = [
        "current stock market trends and outlook",
        "S&P 500 latest performance and forecast",
        "NASDAQ market sentiment this week",
        "global financial market conditions",
        "market volatility indicators current status"
    ]
    import random
    target = random.choice(analysis_targets)
    news_data = get_market_news(target)
    
    if news_data:
        analysis = analyze_market_sentiment(news_data)
        
        # Defensive Check: Ensure 'analysis' is a dictionary before proceeding.
        if not isinstance(analysis, dict):
            st.error(f"Market analysis failed. The AI model returned an unexpected format: {analysis}")
            return False

        st.session_state.market_data = {
            "latest_analysis": analysis,
            "sentiment": analysis.get("sentiment", "Unknown"), # This line is now safe
            "last_updated": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
            "news_data": news_data,
            "target": target
        }
        return True
        
    return False
def get_stock_data_past_year(ticker):
    end_date = datetime.now()
    start_date = end_date - timedelta(days=365)
    stock = yf.download(ticker, start=start_date, end=end_date)
    return stock['Close']
def calculate_progress_to_goals(goals, savings, expenses):
    if not goals:
        return []
    progress_data = []
    for goal in goals:
        target_amount = goal["target_amount"]
        target_date = datetime.strptime(goal["target_date"], "%Y-%m-%d")
        days_remaining = (target_date - datetime.now()).days
        if days_remaining < 0:
            progress_percentage = 0
            status = "Expired"
        else:
            total_savings = sum(item["amount"] for item in savings.get("accounts", []))
            monthly_expenses = sum(expense["amount"] for expense in expenses)
            progress_percentage = min(100, (total_savings / target_amount) * 100)
            if progress_percentage >= 100:
                status = "Achieved"
            elif days_remaining <= 30 and progress_percentage < 90:
                status = "At Risk"
            else:
                status = "On Track"
        progress_data.append({
            "goal": goal["goal"],
            "target_amount": target_amount,
            "target_date": goal["target_date"],
            "progress_percentage": progress_percentage,
            "status": status,
            "days_remaining": max(0, days_remaining)
        })
    return progress_data
with st.sidebar:
    st.header("Navigation")
    selected_tab = st.radio(
        "Select a tab:",
        ["Chat Assistant", "Personal Finance", "Market Analysis", "Investments", "Smart Dashboard", "Fraud Detection"],
        key="tab_selector"
    )
if selected_tab == "Chat Assistant":
    for message in st.session_state.messages:
        with st.chat_message(message["role"]):
            st.markdown(message["content"])
    if prompt := st.chat_input("Ask your financial assistant..."):
        st.session_state.messages.append({"role": "user", "content": prompt})
        with st.chat_message("user"):
            st.markdown(prompt)
        with st.chat_message("assistant"):
            with st.spinner("Thinking..."):
                response = get_gemini_response(
                    st.session_state.messages,
                    st.session_state.financial_context,
                    st.session_state.market_data
                )
                st.markdown(response)
        st.session_state.messages.append({"role": "assistant", "content": response})
elif selected_tab == "Personal Finance":
    st.header("Personal Finance Manager")
    pf_tab1, pf_tab2, pf_tab3 = st.tabs(["Financial Goals", "Expense Tracking", "Budget Planning"])
    with pf_tab1:
        st.subheader("Financial Goals")
        col1, col2 = st.columns([2, 1])
        with col1:
            new_goal = st.text_input("Add a new financial goal")
            target_amount = st.number_input("Target Amount ($)", min_value=0, step=1000)
            target_date = st.date_input("Target Date")
            if st.button("Add Goal"):
                if new_goal:
                    goal_details = {
                        "goal": new_goal,
                        "target_amount": target_amount,
                        "target_date": target_date.strftime("%Y-%m-%d"),
                        "created_at": datetime.now().strftime("%Y-%m-%d"),
                        "progress": 0
                    }
                    st.session_state.financial_context["goals"].append(goal_details)
                    st.success(f"Goal added: {new_goal}")
        with col2:
            if not st.session_state.financial_context["savings"]:
                st.session_state.financial_context["savings"] = {"accounts": []}
            savings_amount = st.number_input("Current Savings Amount ($)", min_value=0, step=100)
            savings_name = st.text_input("Savings Account Name", value="General Savings")
            if st.button("Update Savings"):
                existing_account = False
                for account in st.session_state.financial_context["savings"].get("accounts", []):
                    if account["name"] == savings_name:
                        account["amount"] = savings_amount
                        existing_account = True
                        break
                if not existing_account:
                    if "accounts" not in st.session_state.financial_context["savings"]:
                        st.session_state.financial_context["savings"]["accounts"] = []
                    st.session_state.financial_context["savings"]["accounts"].append({
                        "name": savings_name,
                        "amount": savings_amount,
                        "updated_at": datetime.now().strftime("%Y-%m-%d")
                    })
                st.success(f"Savings updated: {savings_name} - ${savings_amount}")
        st.subheader("Your Goals Progress")
        if st.session_state.financial_context["goals"]:
            progress_data = calculate_progress_to_goals(
                st.session_state.financial_context["goals"],
                st.session_state.financial_context["savings"],
                st.session_state.financial_context["expenses"]
            )
            for idx, progress in enumerate(progress_data):
                col1, col2, col3, col4 = st.columns([3, 1, 1, 1])
                with col1:
                    st.write(f"**{progress['goal']}**")
                    st.progress(progress['progress_percentage']/100)
                with col2:
                    st.write(f"${progress['target_amount']}")
                with col3:
                    st.write(f"{progress['days_remaining']} days left")
                with col4:
                    if progress['status'] == "On Track":
                        st.success(progress['status'])
                    elif progress['status'] == "At Risk":
                        st.warning(progress['status'])
                    elif progress['status'] == "Achieved":
                        st.info(progress['status'])
                    else:
                        st.error(progress['status'])
                if st.button(f"Remove Goal {idx+1}"):
                    st.session_state.financial_context["goals"].pop(idx)
                    st.rerun()
        else:
            st.info("No financial goals added yet. Add your first goal above.")
    with pf_tab2:
        st.subheader("Expense Tracker")
        col1, col2 = st.columns([1, 1])
        with col1:
            expense_amount = st.number_input("Expense Amount ($)", min_value=0, step=10)
            expense_category = st.selectbox("Category", st.session_state.budget_categories)
            expense_date = st.date_input("Date of Expense", value=datetime.now())
            expense_note = st.text_input("Note (optional)")
            if st.button("Add Expense"):
                expense = {
                    "amount": expense_amount,
                    "category": expense_category,
                    "date": expense_date.strftime("%Y-%m-%d"),
                    "note": expense_note,
                    "id": len(st.session_state.financial_context["expenses"]) + 1
                }
                st.session_state.financial_context["expenses"].append(expense)
                st.success(f"Expense added: ${expense_amount} for {expense_category}")
        with col2:
            new_category = st.text_input("Add Custom Category")
            if st.button("Add Category") and new_category and new_category not in st.session_state.budget_categories:
                st.session_state.budget_categories.append(new_category)
                st.success(f"Category added: {new_category}")
        st.subheader("Recent Expenses")
        if st.session_state.financial_context["expenses"]:
            expense_data = pd.DataFrame(st.session_state.financial_context["expenses"])
            expense_data = expense_data.sort_values(by="date", ascending=False)
            st.dataframe(expense_data, use_container_width=True)
            if len(expense_data) > 0:
                st.subheader("Expense Analysis")
                category_totals = expense_data.groupby("category")["amount"].sum().reset_index()
                fig = plt.figure(figsize=(10, 6))
                plt.pie(category_totals["amount"], labels=category_totals["category"], autopct="%1.1f%%")
                plt.title("Expense Distribution by Category")
                st.pyplot(fig)
        else:
            st.info("No expenses recorded yet. Add your first expense above.")
        if st.button("Clear All Expenses"):
            st.session_state.financial_context["expenses"] = []
            st.success("All expenses cleared!")
            st.rerun()
    with pf_tab3:
        st.subheader("Budget Planning")
        col1, col2 = st.columns([1, 1])
        with col1:
            budget_category = st.selectbox("Budget Category", st.session_state.budget_categories, key="budget_cat")
            budget_amount = st.number_input("Monthly Budget ($)", min_value=0, step=100)
            if st.button("Set Budget"):
                if "budgets" not in st.session_state.financial_context["budget"]:
                    st.session_state.financial_context["budget"]["budgets"] = {}
                st.session_state.financial_context["budget"]["budgets"][budget_category] = budget_amount
                st.success(f"Budget set: ${budget_amount} for {budget_category}")
        with col2:
            monthly_income = st.number_input("Monthly Income ($)", min_value=0, step=100)
            if st.button("Set Income"):
                st.session_state.financial_context["budget"]["income"] = monthly_income
                st.success(f"Monthly income set: ${monthly_income}")
        st.subheader("Your Budget vs. Actual Spending")
        if "budgets" in st.session_state.financial_context["budget"]:
            budgets = st.session_state.financial_context["budget"]["budgets"]
            if budgets and st.session_state.financial_context["expenses"]:
                expense_df = pd.DataFrame(st.session_state.financial_context["expenses"])
                current_month = datetime.now().strftime("%Y-%m")
                expense_df["month"] = expense_df["date"].apply(lambda x: x[:7])
                monthly_expenses = expense_df[expense_df["month"] == current_month]
                expense_by_category = monthly_expenses.groupby("category")["amount"].sum().to_dict()
                budget_comparison = []
                for category, budget in budgets.items():
                    actual = expense_by_category.get(category, 0)
                    remaining = budget - actual
                    percentage = min(100, (actual / budget) * 100) if budget > 0 else 0
                    budget_comparison.append({
                        "category": category,
                        "budget": budget,
                        "actual": actual,
                        "remaining": remaining,
                        "percentage": percentage
                    })
                budget_df = pd.DataFrame(budget_comparison)
                st.dataframe(budget_df, use_container_width=True)
                for idx, row in budget_df.iterrows():
                    st.write(f"**{row['category']}**: ${row['actual']} of ${row['budget']}")
                    col1, col2 = st.columns([4, 1])
                    with col1:
                        progress_color = "normal"
                        if row['percentage'] > 90:
                            progress_color = "red"
                        elif row['percentage'] > 75:
                            progress_color = "orange"
                        st.progress(row['percentage']/100)
                    with col2:
                        st.write(f"${row['remaining']} left")
                if "income" in st.session_state.financial_context["budget"]:
                    income = st.session_state.financial_context["budget"]["income"]
                    total_expenses = expense_by_category.values()
                    total_monthly_expense = sum(total_expenses) if total_expenses else 0
                    savings_potential = income - total_monthly_expense
                    st.subheader("Monthly Overview")
                    col1, col2, col3 = st.columns(3)
                    with col1:
                        st.metric("Income", f"${income}")
                    with col2:
                        st.metric("Expenses", f"${total_monthly_expense}")
                    with col3:
                        st.metric("Potential Savings", f"${savings_potential}")
            else:
                st.info("Set budgets and record expenses to see your budget analysis.")
        else:
            st.info("No budgets set yet. Create your first budget above.")
elif selected_tab == "Market Analysis":
    st.header("AI-powered Market Analysis")
    col1, col2 = st.columns([4, 1])
    with col2:
        refresh = st.button("Refresh Analysis")
    if refresh or st.session_state.market_data["latest_analysis"] is None:
        with st.spinner("Analyzing market conditions..."):
            success = run_automatic_market_analysis()
            if success:
                st.success("Market analysis updated!")
            else:
                st.error("Failed to update market analysis. Please try again later.")
    if st.session_state.market_data.get("latest_analysis"):
        analysis = st.session_state.market_data["latest_analysis"]
        st.caption(f"Analysis based on: {st.session_state.market_data.get('target', 'market conditions')}")
        sentiment = analysis.get("sentiment", "").lower()
        if "bull" in sentiment:
            sentiment_color = "green"
            sentiment_emoji = "üìà"
        elif "bear" in sentiment:
            sentiment_color = "red"
            sentiment_emoji = "üìâ"
        else:
            sentiment_color = "gray"
            sentiment_emoji = "‚öñÔ∏è"
        st.markdown(f"""
        <div style="display: flex; align-items: center; margin-bottom: 20px;">
            <h3 style="margin-right: 10px;">Market Sentiment:</h3>
            <div style="background-color: {sentiment_color}; color: white; padding: 5px 15px; border-radius: 20px; display: inline-block;">
                {sentiment_emoji} {analysis.get("sentiment", "Unknown").upper()}
            </div>
            <div style="margin-left: 20px; color: gray; font-size: 0.8em;">
                Confidence: {analysis.get("confidence_score", "N/A")}%
            </div>
        </div>
        """, unsafe_allow_html=True)
        st.subheader("Market Summary")
        st.write(analysis.get("summary", "No summary available"))
        st.subheader("Key Trends")
        trends = analysis.get("trends", [])
        if isinstance(trends, list) and trends:
            formatted_trends = "\n".join([f"{i+1}. {trend}" for i, trend in enumerate(trends)])
            st.write(formatted_trends)
        else:
            st.write("No trends identified")
        st.subheader("Market Outlook")
        outlook = analysis.get("outlook", "").lower()
        if "positive" in outlook:
            st.success(analysis.get("outlook", "Uncertain"))
        elif "negative" in outlook:
            st.error(analysis.get("outlook", "Uncertain"))
        else:
            st.info(analysis.get("outlook", "Uncertain"))
        news_data = st.session_state.market_data.get("news_data", {})
        if "organic" in news_data:
            with st.expander("View News Sources"):
                for i, article in enumerate(news_data["organic"][:5], 1):
                    st.markdown(f"**{i}. {article.get('title', 'No title')}**")
                    st.markdown(f"{article.get('snippet', 'No snippet')}")
                    if article.get('link'):
                        st.markdown(f"[Read more]({article.get('link')})")
                    st.divider()
        st.caption(f"Last updated: {st.session_state.market_data['last_updated']}")
    else:
        st.info("No market analysis available. Click 'Refresh Analysis' to generate one.")
elif selected_tab == "Investments":
    st.header("Investment Manager")
    inv_tab1, inv_tab2, inv_tab3, inv_tab4 = st.tabs(["Stock Predictions", "Portfolio Tracker", "Strategic Insights", "AI Future Outlook"])

    with inv_tab1:
        st.subheader("Stock Price Analysis and Forecasting")
        stock_options = {
            'AAPL': 'Apple',
            'GOOGL': 'Google',
            'NVDA': 'NVIDIA',
            'TSLA': 'Tesla'
        }
        
        # Updated and more robust image mapping
        image_map = {
            'AAPL': {
                'forecast': 'images/aapl_forecast.png',
                'seasonal': 'images/aapl_seasonal.png',
                'trend': 'images/trend_aapl.png'
            },
            'GOOGL': {
                'forecast': 'images/google_forecast.png',
                'seasonal': 'images/googl_seasonal.png',
                'trend': 'images/trend_googl.png'
            },
            'NVDA': {
                'forecast': 'images/nvda_forecast.png',
                'seasonal': 'images/seasonal_nvda.png',
                'trend': 'images/trend_nvda.png'
            },
            'TSLA': {
                'forecast': 'images/tsla_forecast.png',
                'seasonal': 'images/tsla_seasonal.png',
                'trend': 'images/trend_tsla.png'
            }
        }

        selected_stock = st.selectbox(
            "Select a stock to analyze:",
            options=list(stock_options.keys()),
            format_func=lambda x: stock_options[x],
            key="prediction_stock"
        )

        with st.spinner(f"Fetching historical data for {selected_stock}..."):
            historical_data = get_stock_data_past_year(selected_stock)

        # Tab for historical data
        st.subheader(f"Historical Price (Last Year) for {stock_options[selected_stock]}")
        fig, ax = plt.subplots(figsize=(10, 5))
        ax.plot(historical_data.index, historical_data.values, color='blue', linewidth=2, label='Historical Close')
        ax.scatter(historical_data.index[-1], historical_data.values[-1], color='red', s=100, zorder=5, label='Last Close Price')
        ax.set_title(f"{selected_stock} Historical Stock Price (Last Year)")
        ax.set_xlabel("Date")
        ax.set_ylabel("Price ($)")
        ax.legend()
        ax.grid(True, linestyle='--', alpha=0.6)
        st.pyplot(fig)

        hist_start = float(historical_data.iloc[0])
        hist_end = float(historical_data.iloc[-1])
        hist_change_pct = ((hist_end - hist_start) / hist_start) * 100 if hist_start != 0 else 0
        
        col1, col2 = st.columns(2)
        with col1:
            st.metric("Starting Price (1yr ago)", f"${hist_start:.2f}")
        with col2:
            st.metric("Current Price", f"${hist_end:.2f}", f"{hist_change_pct:.2f}%")

        st.divider()

        # Tabs for Forecast, Trend, and Seasonality images
        st.subheader(f"Forecast and Time Series Decomposition for {stock_options[selected_stock]}")
        
        forecast_tab, trend_tab, seasonal_tab = st.tabs(["1-Month Forecast", "Trend Analysis", "Seasonality Analysis"])

        stock_images = image_map.get(selected_stock, {})
        
        with forecast_tab:
            forecast_image_path = stock_images.get('forecast')
            if forecast_image_path and os.path.exists(forecast_image_path):
                st.image(forecast_image_path, caption=f"1-Month Price Forecast for {selected_stock}", use_column_width=True)
            else:
                st.error(f"Forecast image not found for {selected_stock}.")

        with trend_tab:
            trend_image_path = stock_images.get('trend')
            if trend_image_path and os.path.exists(trend_image_path):
                st.image(trend_image_path, caption=f"Long-term Trend Component for {selected_stock}", use_column_width=True)
            else:
                st.error(f"Trend analysis image not found for {selected_stock}.")

        with seasonal_tab:
            seasonal_image_path = stock_images.get('seasonal')
            if seasonal_image_path and os.path.exists(seasonal_image_path):
                st.image(seasonal_image_path, caption=f"Seasonal Pattern Component for {selected_stock}", use_column_width=True)
            else:
                st.error(f"Seasonality analysis image not found for {selected_stock}.")
        
        

        st.info(
            "**Disclaimer**: These forecasts and analyses are generated by advanced time-series models for informational purposes only. "
            "Stock market investments involve significant risk, and past performance is not indicative of future results."
        )

        # Expander for the detailed XAI explanation
        with st.expander("**Explain How This Analysis Is Made (Explainable AI)**"):
            if st.button("Generate Detailed Explanation", key=f"explain_{selected_stock}"):
                with st.spinner("Generating explanation from the financial AI model..."):
                    # This function needs to be updated or replaced with the new version below
                    explanation = get_explainable_ai_forecast(selected_stock)
                    st.markdown(explanation)
    with inv_tab2:
        st.subheader("Portfolio Tracker")
        if not st.session_state.financial_context["portfolio"]:
            st.session_state.financial_context["portfolio"] = []
        col1, col2, col3 = st.columns(3)
        with col1:
            stock_ticker = st.text_input("Stock Ticker Symbol", key="portfolio_ticker").upper()
        with col2:
            shares = st.number_input("Number of Shares", min_value=0.01, step=0.01, key="portfolio_shares")
        with col3:
            purchase_price = st.number_input("Purchase Price per Share ($)", min_value=0.01, step=0.01, key="portfolio_price")
        purchase_date = st.date_input("Purchase Date", key="portfolio_date")
        notes = st.text_input("Notes (optional)", key="portfolio_notes")
        if st.button("Add to Portfolio"):
            if stock_ticker and shares > 0 and purchase_price > 0:
                try:
                    stock = yf.Ticker(stock_ticker)
                    current_price = stock.history(period="1d")['Close'].iloc[-1]
                    current_value = current_price * shares
                    purchase_value = purchase_price * shares
                    profit_loss = current_value - purchase_value
                    profit_loss_percent = (profit_loss / purchase_value) * 100
                    portfolio_entry = {
                        "ticker": stock_ticker,
                        "shares": shares,
                        "purchase_price": purchase_price,
                        "purchase_date": purchase_date.strftime("%Y-%m-%d"),
                        "purchase_value": purchase_value,
                        "current_price": current_price,
                        "current_value": current_value,
                        "profit_loss": profit_loss,
                        "profit_loss_percent": profit_loss_percent,
                        "notes": notes,
                        "last_updated": datetime.now().strftime("%Y-%m-%d %H:%M:%S")
                    }
                    st.session_state.financial_context["portfolio"].append(portfolio_entry)
                    st.success(f"Added {shares} shares of {stock_ticker} to portfolio!")
                except Exception as e:
                    st.error(f"Error: {e}. Please check the ticker symbol and try again.")
            else:
                st.warning("Please fill in all required fields.")
        if st.session_state.financial_context["portfolio"]:
            portfolio = st.session_state.financial_context["portfolio"]
            if st.button("Refresh Portfolio Prices"):
                with st.spinner("Updating portfolio prices..."):
                    for i, stock in enumerate(portfolio):
                        try:
                            ticker_data = yf.Ticker(stock["ticker"])
                            current_price = ticker_data.history(period="1d")['Close'].iloc[-1]
                            portfolio[i]["current_price"] = current_price
                            portfolio[i]["current_value"] = current_price * stock["shares"]
                            portfolio[i]["profit_loss"] = portfolio[i]["current_value"] - stock["purchase_value"]
                            portfolio[i]["profit_loss_percent"] = (portfolio[i]["profit_loss"] / stock["purchase_value"]) * 100
                            portfolio[i]["last_updated"] = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
                        except:
                            st.warning(f"Could not update {stock['ticker']}. Skipping.")
                    st.success("Portfolio prices updated!")
            total_investment = sum(stock["purchase_value"] for stock in portfolio)
            total_current_value = sum(stock["current_value"] for stock in portfolio)
            total_profit_loss = total_current_value - total_investment
            total_profit_loss_percent = (total_profit_loss / total_investment) * 100 if total_investment > 0 else 0
            col1, col2, col3 = st.columns(3)
            with col1:
                st.metric("Total Investment", f"${total_investment:.2f}")
            with col2:
                st.metric("Current Value", f"${total_current_value:.2f}")
            with col3:
                st.metric("Profit/Loss", f"${total_profit_loss:.2f}", f"{total_profit_loss_percent:.2f}%")
            portfolio_df = pd.DataFrame(portfolio)
            portfolio_df = portfolio_df[["ticker", "shares", "purchase_price", "current_price",
                                        "purchase_value", "current_value", "profit_loss", "profit_loss_percent"]]
            formatted_df = portfolio_df.copy()
            formatted_df["purchase_price"] = formatted_df["purchase_price"].map("${:.2f}".format)
            formatted_df["current_price"] = formatted_df["current_price"].map("${:.2f}".format)
            formatted_df["purchase_value"] = formatted_df["purchase_value"].map("${:.2f}".format)
            formatted_df["current_value"] = formatted_df["current_value"].map("${:.2f}".format)
            formatted_df["profit_loss"] = formatted_df["profit_loss"].map("${:.2f}".format)
            formatted_df["profit_loss_percent"] = formatted_df["profit_loss_percent"].map("{:.2f}%".format)
            formatted_df.columns = ["Ticker", "Shares", "Buy Price", "Current Price",
                                "Cost Basis", "Current Value", "Profit/Loss", "Return %"]
            st.dataframe(formatted_df, use_container_width=True)
            if len(portfolio) > 0:
                fig = go.Figure(data=[go.Pie(
                    labels=[stock["ticker"] for stock in portfolio],
                    values=[stock["current_value"] for stock in portfolio],
                    hole=.4,
                    textinfo='label+percent'
                )])
                fig.update_layout(title="Portfolio Allocation")
                st.plotly_chart(fig, use_container_width=True)
                performance_data = [
                    go.Bar(
                        name="Cost Basis",
                        x=[stock["ticker"] for stock in portfolio],
                        y=[stock["purchase_value"] for stock in portfolio],
                        marker_color='blue'
                    ),
                    go.Bar(
                        name="Current Value",
                        x=[stock["ticker"] for stock in portfolio],
                        y=[stock["current_value"] for stock in portfolio],
                        marker_color='green'
                    )
                ]
                performance_layout = go.Layout(
                    title="Investment Performance by Stock",
                    barmode='group',
                    xaxis_title="Stock",
                    yaxis_title="Value ($)"
                )
                fig = go.Figure(data=performance_data, layout=performance_layout)
                st.plotly_chart(fig, use_container_width=True)
            if st.button("Remove Selected Stock"):
                st.info("Select the stock to remove:")
                for i, stock in enumerate(portfolio):
                    if st.checkbox(f"{stock['ticker']} - {stock['shares']} shares", key=f"delete_{i}"):
                        st.session_state.financial_context["portfolio"].pop(i)
                        st.success(f"Removed {stock['ticker']} from portfolio!")
                        st.rerun()
        else:
            st.info("Your portfolio is empty. Add your first stock above!")
    with inv_tab3:
        st.subheader("AI-Powered Strategic Insights")
        if not st.session_state.financial_context["portfolio"]:
            st.info("Please add stocks to your portfolio in the 'Portfolio Tracker' tab to get strategic insights.")
        else:
            st.write("This tool uses a Large Language Model to analyze your current portfolio against real-time market data, providing strategic insights and actionable recommendations.")
            if st.button("Generate Strategic Portfolio Analysis"):
                with st.spinner("Your AI strategist is analyzing your portfolio and the market..."):
                    portfolio_data = st.session_state.financial_context["portfolio"]
                    market_data = st.session_state.market_data
                    if market_data.get("latest_analysis") is None:
                        st.warning("Market data is not available. Running a quick analysis first.")
                        run_automatic_market_analysis()
                        market_data = st.session_state.market_data
                    if market_data.get("latest_analysis"):
                        insights = get_portfolio_insights(portfolio_data, market_data)
                        st.markdown(insights)
                    else:
                        st.error("Could not fetch market data. Unable to generate insights.")

    # --- ADD THIS NEW BLOCK ---
    with inv_tab4:
        st.subheader(f"AI-Powered Outlook for {stock_options[selected_stock]}")
        st.write("This analysis uses the stock's 1-year performance as context to interpret the 1-month forecast.")
        
        # Display the metrics for user context
        st.metric(label="Current Price", value=f"${hist_end:.2f}", delta=f"{hist_change_pct:.2f}% (Last 12 Months)")
        
        if st.button(f"Generate Future Outlook for {selected_stock}", key=f"outlook_{selected_stock}"):
            with st.spinner(f"Your AI analyst is interpreting the forecast for {selected_stock}..."):
                # --- MODIFIED: Pass the new data to the function ---
                outlook_explanation = get_future_outlook_explanation(
                    ticker=selected_stock,
                    start_price=hist_start,
                    current_price=hist_end,
                    growth_rate=hist_change_pct
                )
                st.markdown(outlook_explanation)
if selected_tab == "Smart Dashboard":
    st.title("üí∞ Smart Financial Dashboard")
    st.subheader("Your Complete Financial Overview")
    col1, col2 = st.columns([3, 2])
    with col1:
        st.markdown("### üìä Financial Summary")
        with st.expander("View Complete Summary", expanded=True):
            total_expenses = sum(expense["amount"] for expense in st.session_state.financial_context.get("expenses", []))
            monthly_income = st.session_state.financial_context.get("budget", {}).get("income", 0)
            total_savings = monthly_income-total_expenses
            metric1, metric2, metric3 = st.columns(3)
            with metric1:
                st.metric("Total Savings", f"${total_savings:,.2f}")
            with metric2:
                st.metric("Monthly Income", f"${monthly_income:,.2f}")
            with metric3:
                st.metric("Monthly Expenses", f"${total_expenses:,.2f}")
            if monthly_income > 0:
                savings_rate = (total_savings / monthly_income) * 100
                st.progress(min(100, int(savings_rate)))
                st.caption(f"Savings Rate: {savings_rate:.1f}% of monthly income")
            if st.session_state.financial_context.get("goals"):
                st.markdown("### üéØ Goals Progress")
                for goal in st.session_state.financial_context["goals"]:
                    target_date = datetime.strptime(goal["target_date"], "%Y-%m-%d")
                    days_remaining = (target_date - datetime.now()).days
                    progress = min(100, (total_savings / goal["target_amount"]) * 100) if goal["target_amount"] > 0 else 0
                    st.write(f"**{goal['goal']}** - ${goal['target_amount']:,.2f}")
                    st.progress(progress/100)
                    st.caption(f"{days_remaining} days remaining - {progress:.1f}% complete")
    with col2:
        st.markdown("### üí° Quick Insights")
        with st.expander("View Insights", expanded=True):
            if monthly_income > 0 and total_expenses > 0:
                expense_ratio = (total_expenses / monthly_income) * 100
                if expense_ratio > 80:
                    st.warning(f"‚ö†Ô∏è High expense ratio! You're spending {expense_ratio:.1f}% of your income")
                elif expense_ratio > 60:
                    st.info(f"‚ÑπÔ∏è Moderate expense ratio: {expense_ratio:.1f}% of income")
                else:
                    st.success(f"‚úÖ Healthy expense ratio: {expense_ratio:.1f}% of income")
            if st.session_state.financial_context.get("portfolio"):
                portfolio_value = sum(stock["current_value"] for stock in st.session_state.financial_context["portfolio"])
                st.metric("Portfolio Value", f"${portfolio_value:,.2f}")
    st.markdown("---")
    st.markdown("### üìà Investment Report")
    if st.button("Generate Full Report"):
        with st.spinner("Generating comprehensive report..."):
            report_tab1, report_tab2, report_tab3 = st.tabs(["Portfolio Analysis", "Income vs Expenses", "Predictions"])
            with report_tab1:
                if st.session_state.financial_context.get("portfolio"):
                    st.markdown("#### Portfolio Performance")
                    portfolio = st.session_state.financial_context["portfolio"]
                    fig = go.Figure()
                    for stock in portfolio:
                        fig.add_trace(go.Bar(
                            x=[stock["ticker"]],
                            y=[stock["current_value"]],
                            name=stock["ticker"],
                            text=[f"${stock['current_value']:,.2f}<br>Return: {stock['profit_loss_percent']:.1f}%"],
                            textposition='auto'
                        ))
                    fig.update_layout(barmode='stack', title="Current Portfolio Value")
                    st.plotly_chart(fig, use_container_width=True)
                    st.markdown("#### Individual Stock Performance")
                    for stock in portfolio:
                        col1, col2, col3 = st.columns([1,2,1])
                        with col1:
                            st.metric(stock["ticker"], f"${stock['current_price']:.2f}")
                        with col2:
                            st.progress(min(1.0, max(0.0, (stock["profit_loss_percent"] + 50)/100)))
                        with col3:
                            st.metric("Return", f"{stock['profit_loss_percent']:.1f}%",
                                    f"${stock['profit_loss']:.2f}")
            with report_tab2:
                st.markdown("#### Income vs Expenses")
                if monthly_income > 0:
                    categories = {}
                    for expense in st.session_state.financial_context.get("expenses", []):
                        categories[expense["category"]] = categories.get(expense["category"], 0) + expense["amount"]
                    if categories:
                        fig = go.Figure()
                        fig.add_trace(go.Pie(
                            labels=list(categories.keys()),
                            values=list(categories.values()),
                            hole=0.4,
                            textinfo='label+percent'
                        ))
                        fig.update_layout(title="Expense Breakdown")
                        st.plotly_chart(fig, use_container_width=True)
                        if "budgets" in st.session_state.financial_context.get("budget", {}):
                            budget_data = []
                            for category, budget in st.session_state.financial_context["budget"]["budgets"].items():
                                actual = categories.get(category, 0)
                                budget_data.append({
                                    "Category": category,
                                    "Budget": budget,
                                    "Actual": actual,
                                    "Difference": budget - actual
                                })
                            budget_df = pd.DataFrame(budget_data)
                            st.dataframe(budget_df, use_container_width=True)
            with report_tab3:
                st.markdown("#### 1-Month Predictions")
                st.info("Prediction charts are available in the 'Investments' > 'Stock Predictions' tab.")
elif selected_tab == "Fraud Detection":
    st.title("Fraud Detection")
    col1, col2 = st.columns([3, 2])
    with col1:
        st.subheader("Add New Transaction")
        with st.form("transaction_form"):
            date = st.date_input("Transaction Date", datetime.now())
            time = st.time_input("Transaction Time", datetime.now().time())
            amount = st.number_input("Amount", min_value=0.01, step=0.01)
            merchant = st.text_input("Merchant Name")
            category = st.selectbox(
                "Category",
                ["Groceries", "Dining", "Shopping", "Entertainment", "Travel", "Services", "Other"]
            )
            location = st.text_input("Location (City, State)")
            location_usual = st.checkbox("Is this your usual location?", value=True)
            category_usual = st.checkbox("Is this a usual merchant category for you?", value=True)
            time_usual = st.checkbox("Is this a usual transaction time for you?", value=True)
            submitted = st.form_submit_button("Add Transaction")
            if submitted:
                transaction = {
                    "date": date.strftime("%Y-%m-%d"),
                    "time": time.strftime("%H:%M:%S"),
                    "amount": amount,
                    "merchant": merchant,
                    "category": category,
                    "location": location,
                    "location_usual": location_usual,
                    "category_usual": category_usual,
                    "time_usual": time_usual,
                    "rapid_succession": False
                }
                recent_transactions = [
                    t for t in st.session_state.transactions
                    if datetime.strptime(t['date'], "%Y-%m-%d").date() >= (date - timedelta(days=1))
                ]
                if len(recent_transactions) >= 3:
                    transaction["rapid_succession"] = True
                st.session_state.transactions.append(transaction)
                st.success("Transaction added successfully!")
    with col2:
        st.subheader("Fraud Detection Settings")
        detection_threshold = st.slider(
            "Detection Sensitivity",
            min_value=30,
            max_value=70,
            value=40,
            help="Lower values will flag more transactions as potentially fraudulent"
        )
        if st.button("Run Fraud Detection"):
            with st.spinner("Analyzing transactions for potential fraud..."):
                fraud_indicators = detect_fraud_in_transactions(st.session_state.transactions)
                if fraud_indicators:
                    st.warning(f"Detected {len(fraud_indicators)} potentially fraudulent transactions")
                else:
                    st.success("No potentially fraudulent transactions detected")
    st.subheader("Transaction History")
    if not st.session_state.transactions:
        st.info("No transactions recorded yet. Add transactions using the form above.")
    else:
        df_transactions = pd.DataFrame(st.session_state.transactions)
        if 'fraud_score' not in df_transactions.columns:
            df_transactions['fraud_score'] = 0
        def highlight_fraud(row):
            if row['fraud_score'] >= 40:
                return ['background-color: #ffcccc'] * len(row)
            return [''] * len(row)
        st.dataframe(
            df_transactions.style.apply(highlight_fraud, axis=1),
            use_container_width=True
        )
    if len(st.session_state.transactions) >= 5:
        st.subheader("Fraud Pattern Visualization")
        viz_tab1, viz_tab2 = st.tabs(["Transaction Amounts", "Categories"])
        with viz_tab1:
            df = pd.DataFrame(st.session_state.transactions)
            fig = make_subplots(specs=[[{"secondary_y": True}]])
            fig.add_trace(
                go.Scatter(
                    x=df['date'],
                    y=df['amount'],
                    mode='markers',
                    name='Transaction Amount',
                    marker=dict(
                        size=10,
                        color=df['fraud_score'],
                        colorscale='Viridis',
                        showscale=True,
                        colorbar=dict(title="Fraud Score")
                    )
                ),
                secondary_y=False,
            )
            if len(df) > 3:
                df = df.sort_values('date')
                df['rolling_avg'] = df['amount'].rolling(window=3).mean()
                fig.add_trace(
                    go.Scatter(
                        x=df['date'],
                        y=df['rolling_avg'],
                        mode='lines',
                        name='3-Day Rolling Average',
                        line=dict(color='red', width=2)
                    ),
                    secondary_y=False,
                )
            fig.update_layout(
                title_text="Transaction Amounts Over Time",
                xaxis_title="Date",
                legend=dict(orientation="h", yanchor="bottom", y=1.02, xanchor="right", x=1)
            )
            fig.update_yaxes(title_text="Amount", secondary_y=False)
            st.plotly_chart(fig, use_container_width=True)
        with viz_tab2:
            category_counts = df['category'].value_counts().reset_index()
            category_counts.columns = ['category', 'count']
            category_fraud = df.groupby('category')['fraud_score'].mean().reset_index()
            category_fraud.columns = ['category', 'avg_fraud_score']
            category_data = pd.merge(category_counts, category_fraud, on='category')
            fig = go.Figure()
            fig.add_trace(go.Bar(
                x=category_data['category'],
                y=category_data['count'],
                marker=dict(
                    color=category_data['avg_fraud_score'],
                    colorscale='Viridis',
                    showscale=True,
                    colorbar=dict(title="Avg Fraud Score")
                ),
                text=category_data['avg_fraud_score'].round(1),
                textposition='auto',
            ))
            fig.update_layout(
                title_text="Transaction Categories with Fraud Risk",
                xaxis_title="Category",
                yaxis_title="Number of Transactions"
            )
            st.plotly_chart(fig, use_container_width=True)
    st.subheader("Fraud Insights")
    if len(st.session_state.transactions) > 0:
        fraud_indicators = detect_fraud_in_transactions(st.session_state.transactions)
        if fraud_indicators:
            for i, transaction in enumerate(fraud_indicators):
                with st.expander(f"Suspicious Transaction: {transaction['merchant']} - ${transaction['amount']:.2f} on {transaction['date']}"):
                    st.write(f"**Fraud Score:** {transaction['fraud_score']}/100")
                    st.write("**Reasons flagged:**")
                    for reason in transaction['fraud_reasons']:
                        st.write(f"- {reason}")
                    st.write("**Transaction Details:**")
                    for key, value in transaction.items():
                        if key not in ['fraud_score', 'fraud_reasons']:
                            st.write(f"- {key.replace('_', ' ').title()}: {value}")
                    st.write("**Recommendation:**")
                    if transaction['fraud_score'] > 60:
                        st.error("High risk transaction. Consider contacting your bank immediately.")
                    elif transaction['fraud_score'] > 40:
                        st.warning("Moderate risk. Verify this transaction with your records.")
                    else:
                        st.info("Low risk. Normal transaction pattern.")
        else:
            st.info("No suspicious transactions detected in your transaction history.")
